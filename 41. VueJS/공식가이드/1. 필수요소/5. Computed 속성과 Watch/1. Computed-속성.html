<html>
<head>
  <meta charset="utf-8">
</head>

<!-- Computed 속성 -->
<body>
	<!-- 1. Computed 속성 - 기본 예제
	- author가 이미 책이 있는지 없는지 여부에 따라 다른 메시지를 주기를 원할 때,
	- 아래의 템플릿은 단순하고 선언적이지 않음.
	- 계산해야 할 내용이 추가된다면 더 복잡해질 수 있음.
	- 때문에 반응형 데이터를 포함하는 복잡한 로직의 경우, Computed 속성 사용
	-->
	<div id="computed-basics1"> <!-- Computed 속성 사용하지 않은 예 -->
		<p>출판된 책:</p>
		<span>{{ author.books.length > 0 ? '있음' : '없음' }}</span>
	</div>
	
	<div id="computed-basics2"> <!-- Computed 속성 사용 예 -->
		<p>출판된 책:</p>
		<span>{{ publishedBooksMessage }}</span>
	</div>
	
	<!-- 2. Computed 속성의 캐싱 vs 메서드
	- 표현식에서 메서드를 호출하는 방법을 사용할 수 있다.
	-->
	<p id="computed-basics3">{{ calculateBooksMessage() }}</p>
	
</body>

<script src="https://unpkg.com/vue@next"></script>
<script type="text/javascript">
	/* 1. Computed 속성 - 기본 예제
	- 템플릿 안에서 너무 많은 연산을 하면 편리하지만, 코드가 비대해지고 유지보수가 어렵기 때문에 간단한 연산을 위해 Computed 속성을 사용
	- publishedBooksMessage라는 Computed 속성 선언
	- 이 어플리케이션에서는 data의 book 배열의 값이 변경되면 그에 따라 publishedBooksMessage의 변화를 볼 수 있다.
	- 템플릿에서 computed 속성도 데이터 바인딩 가능
	- Vue는 vm.publishedBooksMessage가 vm.author.books에 의존적이어서, vm.author.books가 변경될 때 vm.publishedBooksMessage에 의존하는 모든 바인딩 업데이트함.
	- 종속성 관계를 선언적으로 만들었기 때문에 좋고, computed getter 함수에 사이드 이펙트가 없어서 테스트 및 이해가 쉬움
	*/
	Vue.createApp({ // 중첩된 배열이 있는 객체를 가진 경우의 예
		data() {
			return {
				author: {
					name: '존 도우',
					books: [
						'Vue 2 - Advanced Guide',
						'Vue 3 - Basic Guide',
						'Vue 4 - The Mystery'
					]
				}
			}
		}, // 여기까지는 Computed 속성을 사용하지 않은 예
		computed: { // 여기서부터 Computed 속성 사용 예
			// computed getter
			publishedBooksMessage() {
				// 여기서의 'this'는 vm 인스턴스이다.
				return this.author.books.length > 0 ? '있음' : '없음'
			}
		/* 2. Computed 속성의 캐싱 vs 메서드
		- Computed 속성 대신 메서드를 사용할 수 있음.
		- 결과값은 정확히 동일함. 차이점은 Computed 속성은 반응형(reactive) 종속성에 기반하여 캐시됨.
		- author.books가 변경이 없다면 publishedBooksMessage computed 속성은 여러번 접근하더라도 함수의 재실행 없이 이전 계산 결과를 반환
		- Date.now() 같이 반응형 종속성이 아닌 경우는 computed 속성이 업데이트 되지 않음.
		- 캐싱이 필요한 이유는 크기가 큰 list가 있을때 list의 getter가 불필요하게 많이 실행될 수 있기 때문
		*/
		}, 
		methods: { // 메소드 호출의 경우 렌더링이 발생할 때마다 항상 함수가 실행됌.
			calculateBooksMessage() {
				return this.author.books.length > 0 ? '있음' : '없음'
			}
		}
	}).mount('#computed-basics1') // #computed-basics1~#computed-basics3 바꿔가면서 테스트
	
	/* 3. Computed 속성의 Setter
	- Computed 속성은 기본적으로 getter 이지만, 필요할 때엔 setter 도 제공할 수 있음
	// ...
	computed: {
		fullName: {
			// getter
			get() {
				return this.firstName + ' ' + this.lastName
			},
			// setter
			set(newValue) {
				const names = newValue.split(' ')
				this.firstName = names[0]
				this.lastName = names[names.length - 1]
			}
		}
	}
	// ...
	- vm.fullName = 'John Doe'를 실행하면, setter가 호출되고 vm.firstName과 vm.lastName이 그에 따라 업데이트 됌
	*/
	
</script>

</html>