<html>
<head>
  <meta charset="utf-8">
</head>

<!-- Methods -->
<body>
	<!-- Methods - 1
	- 컴포넌트 인스턴스의 다른 속성들처럼 methods 또한 컴포넌트 템플릿 내부에서 접근 가능
	- methods는 일반적으로 템플릿 내부에서 이벤트 리스너로 사용
	-->
	<button @click="increment">Up vote</button> <!-- 버튼 클릭시 increment 메소드 호출 -->
	<!-- Methods - 2
	- 템플릿에서 메소드 직접 호출도 가능.
	- computed 속성을 사용하는 편이 더 좋으나, 사용 불가한 경우 메소드 사용이 유용함.
	- JavaScript 표현식을 지원하는 템플릿 어디에서나 메소드 호출이 가능
	-->
	<span :title="toTitleDate(date)"> <!-- toTitleDate나 formatDate 메서드가 반응형 데이터에 접근하면, 템플릿에서 직접 사용한 것처럼 렌더링 종속성으로 추적 -->
		{{ formatDate(date) }}
	</span>
	<!-- (참고)
	템플릿으로부터 호출된 메서드는 데이터 변경 혹은 비동기 프로세스 유발과 같은 부작용이 없어야 합니다. 
	만약 여러분이 이와 같은 작업(부작용으로 여겨지는 작업)을 하고 싶다면 아마 라이프사이클 훅을 대신 사용해야 할 것입니다.
	-->
	
</body>

<script src="https://unpkg.com/vue@next"></script>
<script src="https://unpkg.com/lodash@4.17.20/lodash.min.js"></script>
<script type="text/javascript">
	/* Methods
	- 컴포넌트 인스턴스에 메서드 추가시 Methods 옵션을 사용
	- methods 옵션은 동작하기를 원하는 메서드들이 담긴 하나의 객체여야 함
	- Vue는 methods 안에서 컴포넌트 인스턴스를 항상 참조할 수 있도록 this값을 자동 바인딩, 이 경우 메서드가 이벤트 리스너나 콜백으로 사용될 때, 올바른 this값을 유지할 수 있음.
	- 화살표 함수를 사용하면 적절한 this 바인딩하지 못함. 따라서 methods 정의시 화살표 함수 사용 금지
	*/
	const app = Vue.createApp({
		data() {
			return {
				count: 4
			}
		},
		methods: {
			increment() {
				// 'this'는 컴포넌트 인스턴스를 참조
				this.count++
			}
		}
	})
	
	const vm = app.mount('#app')
	
	console.log(vm.count) // => 4
	
	vm.increment()
	
	console.log(vm.count) // => 5
	
	/* 디바운싱과 쓰로틀링(Debouncing and Throttling)
	- Vue는 디바운싱이나 쓰로틀링에 대한 지원을 자체적으로 제공하지는 않음
	- Lodash와 같은 라이브러리를 사용하여 해당 부분 구현 가능
	- 컴포넌트가 한 번만 사용되는 경우 methods에 디바운싱을 직접 적용 가능, 하지만 이런 방법은 재사용되는 컴포넌트가 모두 동일한 디바운스 함수를 공유하기 때문에 문제 발생 가능성 있음.
	- 컴포넌트 인스턴스를 서로 독립적으로 유지하기 위해 created 라이프사이클 훅에 디바운스 함수를 추가 가능
	*/
	Vue.createApp({
		methods: {
			// Lodash의 디바운싱 적용
			click: _.debounce(function() {
			// ... 클릭에 대한 응답 ...
			}, 500)
		}
	}).mount('#app')
	
	app.component('save-button', {
		created() {
			// Lodash의 디바운싱 적용
			this.debouncedClick = _.debounce(this.click, 500)
		},
		unmounted() {
			// 컴포넌트가 제거되면 타이머를 취소합니다.
			this.debouncedClick.cancel()
		},
		methods: {
			click() {
			// ... 클릭에 대한 응답 ...
			}
		},
		template: '<button @click="debouncedClick">Save</button>'
	})
	
</script>

</html>